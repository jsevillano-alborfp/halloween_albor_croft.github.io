<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>BOO! </title>
    

  </head>
    
  <body>
  <!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Boo!</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">
<style>
  :root {
    --p: 6px;
    --bg0: #0a0a0f;
    --bg1: #111425;
    --floorA: #262b44;
    --floorB: #1c2035;
    --spook: #b9e6ff;
    --spookEdge: #6fb6e6;
    --spookMini: #a0d5f5;
    --spookMiniEdge: #5fa0d0;
    --eye: #002244;
    --mouth: #ff3a6e;
    --fuzBody: #ffffff;
    --fuzEye: #000000;
    --fezRed: #c41e3a;
    --fezTrim: #d4af37;
    --candyWrapper: #ffc40c;
    --candyStripe: #ffffff;
  }

  html,body {
    margin: 0;
    height: 100%;
    background:
      radial-gradient(60% 80% at 50% 10%, rgba(80,90,150,0.15), transparent 60%),
      linear-gradient(180deg, var(--bg1), var(--bg0) 50%, var(--bg1));
    color: #fff;
    font: 14px 'Pixelify Sans';
    overflow: hidden;
    transition: transform 0.1s linear, filter 0.15s linear, background 3s ease-out;
    /* FIX: Prevent Mobile Browser Pull-to-Refresh */
    overscroll-behavior: none;
    -webkit-overflow-scrolling: touch;
    touch-action: none;
  }

  .game {
    position: relative;
    width: 100vw;
    height: 100vh;
    background:
      repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0 calc(var(--p)*2), transparent calc(var(--p)*2) calc(var(--p)*4)),
      repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0 calc(var(--p)*2), transparent calc(var(--p)*2) calc(var(--p)*4));
  }

  .floor {
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    height: calc(var(--p) * 10);
    background:
      linear-gradient(180deg, rgba(0,0,0,0) 0 30%, rgba(0,0,0,0.4)),
      repeating-linear-gradient(90deg, var(--floorA) 0 calc(var(--p)*3), var(--floorB) calc(var(--p)*3) calc(var(--p)*6));
    box-shadow: 0 -4px 0 rgba(0,0,0,0.3) inset, 0 -12px 0 rgba(0,0,0,0.25) inset;
  }

  .actor {
    position: absolute;
    width: var(--p);
    height: var(--p);
    image-rendering: pixelated;
    transform: translate3d(0,0,0);
    will-change: transform, filter, opacity;
    transition: transform 0.08s ease-out, filter 0.2s linear;
  }

  .actor#player.dragged {
    cursor: grabbing;
    z-index: 100;
    filter: drop-shadow(0 10px 8px rgba(0,0,0,0.3));
    transition: none;
  }

  .actor-shadow {
    position: absolute;
    bottom: 15px;
    width: 70px;
    height: 20px;
    background: rgba(0,0,0,0.35);
    border-radius: 50%;
    filter: blur(10px);
    z-index: 0;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, transform 0.05s linear, visibility 0.2s;
    will-change: transform, opacity;
  }

  .score-popup {
    position: absolute;
    color: #ffd700;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 0 0 5px rgba(0,0,0,0.7);
    pointer-events: none;
    z-index: 200;
    will-change: transform, opacity;
    /* For pooling */
    visibility: hidden;
    opacity: 0;
  }
  
  /* Class for pooled particles */
  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 200;
    will-change: transform, opacity;
    /* For pooling */
    visibility: hidden;
    opacity: 0;
  }


  .actor.collected {
    transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    transform-origin: center center;
    transform: scale(2.5) rotate(90deg) !important;
    opacity: 0;
  }

  .glow { filter: drop-shadow(0 0 8px rgba(180,200,255,0.4)); }
  .boosted { filter: drop-shadow(0 0 12px rgba(255,255,100,0.9)); }
  .candy { filter: drop-shadow(0 0 6px rgba(255,220,100,0.7)); font-size: 32px; width: auto; height: auto; }
  .powerup { font-size: 36px; width: auto; height: auto; }
  .web { filter: drop-shadow(0 0 6px rgba(255,100,100,0.7)); font-size: 32px; width: auto; height: auto; }

  .ui {
    position: absolute;
    left: 10px;
    top: 10px;
    background: rgba(0,0,0,0.45);
    padding: 8px 10px;
    border: 1px solid rgba(255,255,255,0.15);
    user-select: none;
    transition: opacity 0.3s, transform 0.1s ease-out, width 0.3s ease-out;
  }
  .ui:active {
    transform: scale(0.95);
  }
  .ui b {
    color: #ffd700;
    transition: color 0.4s, transform 0.1s;
    display: inline-block;
  }

  .ui-meter { display: flex; align-items: center; gap: 8px; width: 180px; }
  .meter-bar { flex-grow: 1; height: 12px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); padding: 1px; }
  #freeze-meter-fill { width: 0%; height: 100%; background: var(--spookEdge); transition: width 0.1s linear; }

  .portal-warp { backdrop-filter: blur(8px) hue-rotate(90deg) saturate(1.5); -webkit-backdrop-filter: blur(8px) hue-rotate(90deg) saturate(1.5); border-radius: 50%; animation: warp-pulse 2s ease-in-out infinite; }
  @keyframes warp-pulse { 0%, 100% { backdrop-filter: blur(8px) hue-rotate(90deg) saturate(1.5); } 50% { backdrop-filter: blur(12px) hue-rotate(120deg) saturate(2); } }
  @media (max-width: 600px) { :root { --p: 4px; } .candy, .powerup, .web { font-size: 24px; } #boo-scare { font-size: 80px; } .ui { padding: 6px 8px; font-size: 12px; } .ui-meter { width: 140px; } }
  @media (max-width: 400px) { :root { --p: 3px; } .candy, .powerup, .web { font-size: 20px; } #boo-scare { font-size: 60px; } .ui { padding: 4px 6px; font-size: 10px; } .ui-meter { width: 120px; } }
</style>
</head>
<body>
<div class="game" id="game" tabindex="0" style="outline: none;">
  <div class="ui" id="instructions" style="top: initial;bottom:20px; z-index: 1;"></div>
  <div class="ui" style="top:10px; right:10px; left:initial;">Level: <b id="level">1</b></div>
  <div class="ui" id="level-score-ui" style="top:45px; right:10px; left:initial; z-index: 1;">Score: <b id="level-score">0</b></div>
  <div class="ui" style="top:80px; right:10px; left:initial; z-index: 1;">Total: <b id="total-score">0</b></div>
  <div class="ui" id="mute-btn" title="Toggle Sound" style="top: 115px; right:10px; left:initial; z-index: 1; cursor: pointer; padding: 8px 12px;">Mute 🔊</div>
  <div class="ui" id="atras-btn" style="top: 155px; right:10px; left:initial; z-index: 1; cursor: pointer; padding: 8px 12px;">atras 🔙</div>
  <script>
    document.getElementById('atras-btn').addEventListener('click', function() {
    window.location.href = '../menu.html'; // Cambia esta ruta por la de tu archivo interno
    });
  </script>
  <div class="ui" id="pause-btn" style="top:195px;right:10px;left:initial;z-index:1;cursor:pointer;padding:8px 12px;display:none;">Pause</div>
  <div class="ui ui-meter" id="freeze-meter-container" style="top: 10px; opacity: 0; z-index: 1;">
    Stare Meter: <div class="meter-bar"><div id="freeze-meter-fill"></div></div>
  </div>
  <div id="boo-scare" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%) scale(0); font-size:120px; pointer-events:none; opacity:0; text-shadow: 0 0 40px rgba(255,60,110,0.8); transition: all 0.1s;">BOO! 👻</div>
  <div class="actor-shadow" id="player-shadow"></div>
  <div class="actor glow" id="player" aria-label="Fuz from Fez" style="cursor: grab;"></div>
  <div class="actor glow" id="spook" aria-label="big spook"></div>
  <div id="mini-ghosts"></div>
  <div id="candies"></div>
  <div id="webs"></div>
  <div class="floor"></div>
</div>

<script>
window.onerror=function(m,s,l,c,e){console.warn("Recovered from:",m);return true;};

const BooAudio = new (function() {
  // --- Existing properties ---
  this.ctx = null; this.masterGain = null; this.sfxGain = null; this.musicGain = null; this.delay = null; this.feedback = null; this.filter = null; this.noiseBuffer = null; this.pinkNoiseBuffer = null; this.metallicNoiseBuffer = null; this.pulseWave25 = null; this.pulseWave12 = null; this.sfxVolume = 0.5; this.musicVolume = 0.15; this.masterVolume = 0.5; this.isMuted = false;

  // --- NEW Properties for continuous sounds ---
  this.thereminOsc = null;
  this.thereminGain = null;
  this.dangerPulseOsc = null;
  this.dangerPulseGain = null;
  this.dangerPulseLFO = null;

  this.init = () => { if (this.ctx) return; this.ctx = new (window.AudioContext || window.webkitAudioContext)(); this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = this.masterVolume; this.sfxGain = this.ctx.createGain(); this.sfxGain.gain.value = this.sfxVolume; this.musicGain = this.ctx.createGain(); this.musicGain.gain.value = this.musicVolume; const comp = this.ctx.createDynamicsCompressor(); comp.threshold.value = -14; comp.ratio.value = 10; comp.attack.value = 0.005; comp.release.value = 0.3; this.sfxGain.connect(comp); this.musicGain.connect(comp); comp.connect(this.masterGain); this.masterGain.connect(this.ctx.destination); this.delay = this.ctx.createDelay(1.5); this.delay.delayTime.value = 0.45; this.feedback = this.ctx.createGain(); this.feedback.gain.value = 0.32; this.filter = this.ctx.createBiquadFilter(); this.filter.type = "lowpass"; this.filter.frequency.value = 1800; this.musicGain.connect(this.delay); this.delay.connect(this.feedback); this.feedback.connect(this.filter); this.filter.connect(this.delay); this.delay.connect(this.masterGain); const modLFO = this.ctx.createOscillator(); const modGain = this.ctx.createGain(); modLFO.frequency.value = 0.03; modGain.gain.value = 300; modLFO.connect(modGain); modGain.connect(this.filter.frequency); modLFO.start(); const bufferSize = this.ctx.sampleRate; this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate); const whiteData = this.noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) whiteData[i] = Math.random() * 2 - 1; this.pinkNoiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate); const pinkData = this.pinkNoiseBuffer.getChannelData(0); let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0; for (let i=0;i<bufferSize;i++){ const white=Math.random()*2-1; b0=0.99886*b0+white*0.0555179; b1=0.99332*b1+white*0.0750759; b2=0.96900*b2+white*0.1538520; b3=0.86650*b3+white*0.3104856; b4=0.55000*b4+white*0.5329522; b5=-0.7616*b5-white*0.0168980; pinkData[i]=(b0+b1+b2+b3+b4+b5+b6+white*0.5362)*0.11; b6=white*0.115926; } const metallicSize=127; this.metallicNoiseBuffer=this.ctx.createBuffer(1,metallicSize,this.ctx.sampleRate); const metallicData=this.metallicNoiseBuffer.getChannelData(0); for(let i=0;i<metallicSize;i++) metallicData[i]=Math.random()*2-1; const real25=new Float32Array([0,1,1,0,0]); const imag25=new Float32Array([0,0,0,0,0]); this.pulseWave25=this.ctx.createPeriodicWave(real25,imag25); const real12=new Float32Array([0,1,0,0,0]); const imag12=new Float32Array([0,0,0,0,0]); this.pulseWave12=this.ctx.createPeriodicWave(real12,imag12); };
  this.toggleMute = () => { if (!this.ctx) return; this.isMuted = !this.isMuted; this.masterGain.gain.linearRampToValueAtTime(this.isMuted ? 0 : this.masterVolume, this.ctx.currentTime + 0.05); };
  const midiToHz = m => 440 * Math.pow(2,(m-69)/12);

  // --- NEW: Theremin functions ---
  this.startTheremin = () => {
    if (!this.ctx || this.thereminOsc) return;
    const t = this.ctx.currentTime;
    this.thereminOsc = this.ctx.createOscillator();
    this.thereminGain = this.ctx.createGain();
    this.thereminOsc.type = 'triangle';
    this.thereminGain.gain.setValueAtTime(0, t);
    this.thereminGain.gain.linearRampToValueAtTime(0.2, t + 0.1); // Fade in
    this.thereminOsc.connect(this.thereminGain);
    this.thereminGain.connect(this.musicGain); // Connect to music gain for effects
    this.thereminOsc.start(t);
  };
  this.updateTheremin = (y) => {
    if (!this.thereminOsc) return;
    // Map vertical position to a spooky frequency range
    const freq = 220 + (1 - y) * 1200;
    this.thereminOsc.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.05);
  };
  this.stopTheremin = () => {
    if (!this.thereminGain) return;
    const t = this.ctx.currentTime;
    this.thereminGain.gain.linearRampToValueAtTime(0, t + 0.2); // Fade out
    this.thereminOsc.stop(t + 0.25);
    this.thereminOsc = null;
    this.thereminGain = null;
  };

  // --- NEW: Danger Pulse functions ---
  this.startDangerPulse = () => {
    if (!this.ctx || this.dangerPulseOsc) return;
    this.dangerPulseOsc = this.ctx.createOscillator();
    this.dangerPulseGain = this.ctx.createGain();
    this.dangerPulseLFO = this.ctx.createOscillator();
    
    this.dangerPulseOsc.type = 'sine';
    this.dangerPulseOsc.frequency.value = 55; // Low A note
    this.dangerPulseGain.gain.value = 0; // Start silent
    
    this.dangerPulseLFO.type = 'square';
    this.dangerPulseLFO.connect(this.dangerPulseGain.gain);
    
    this.dangerPulseOsc.connect(this.dangerPulseGain);
    this.dangerPulseGain.connect(this.musicGain);
    
    this.dangerPulseOsc.start();
    this.dangerPulseLFO.start();
  };
  this.updateDangerPulse = (normalizedDistance) => { // 0 = very close, 1 = far
    if (!this.dangerPulseLFO) return;
    const proximity = 1 - Math.min(1, normalizedDistance);
    const volume = proximity * 0.05;
    const speed = 2 + proximity * 8; // Pulse from 2Hz to 10Hz
    this.dangerPulseGain.gain.value = volume;
    this.dangerPulseLFO.frequency.linearRampToValueAtTime(speed, this.ctx.currentTime + 0.1);
  };

  // --- NEW: Ghost Whisper ---
  this.ghostWhisper = () => {
    if (!this.ctx) return;
    const t = this.ctx.currentTime;
    const source = this.ctx.createBufferSource();
    source.buffer = this.pinkNoiseBuffer;
    
    const bandpass = this.ctx.createBiquadFilter();
    bandpass.type = 'bandpass';
    bandpass.Q.value = 20;
    
    const gain = this.ctx.createGain();
    const panner = this.ctx.createStereoPanner();
    panner.pan.value = Math.random() * 1.6 - 0.8; // Pan slightly left/right

    const startFreq = 800 + Math.random() * 800;
    const endFreq = startFreq + (Math.random() - 0.5) * 400;
    const duration = 1.0 + Math.random() * 1.5;

    bandpass.frequency.setValueAtTime(startFreq, t);
    bandpass.frequency.linearRampToValueAtTime(endFreq, t + duration);
    
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.04, t + duration * 0.2);
    gain.gain.linearRampToValueAtTime(0, t + duration);

    source.connect(bandpass);
    bandpass.connect(gain);
    gain.connect(panner);
    panner.connect(this.musicGain);

    source.start(t);
    source.stop(t + duration + 0.1);
  };
  
  // --- MODIFIED: startAmbientScore to include new sounds ---
  this.startAmbientScore=()=>{
    this.spookyLoop();
    this.ghostPad(196);
    this.startDangerPulse(); // Initialize the danger pulse
    setInterval(()=>this.pwmLead(440,1.2,3,6,0.25),1600);
    setInterval(()=>this.zombieGroove(),1400);
    setInterval(()=>this.randomBell(),12000+Math.random()*8000);
    setInterval(()=>this.ghostWhisper(), 8000 + Math.random() * 6000); // Add whispers
  };

  // --- MODIFIED: portalAmbient for a vortex sound ---
  this.portalAmbient = () => {
    if (!this.ctx) return;
    const t = this.ctx.currentTime;
    const source = this.ctx.createBufferSource();
    source.buffer = this.pinkNoiseBuffer;
    source.loop = true;

    const filter = this.ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.Q.value = 12;
    
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.12, t + 0.5);
    
    const lfo = this.ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 0.2; // Slow swirl
    
    const lfoGain = this.ctx.createGain();
    lfoGain.gain.value = 800;
    
    lfo.connect(lfoGain);
    lfoGain.connect(filter.frequency);
    filter.frequency.value = 1200; // Base frequency

    source.connect(filter);
    filter.connect(gain);
    gain.connect(this.musicGain);

    source.start(t);
    lfo.start(t);
    
    const duration = 2.5;
    gain.gain.linearRampToValueAtTime(0, t + duration);
    source.stop(t + duration + 0.1);
    lfo.stop(t + duration + 0.1);
  };
  
  // --- All other existing sound functions (unchanged) ---
  this.ghostUnfreeze=()=>{if(!this.ctx)return;const t=this.ctx.currentTime;const n=this.ctx.createBufferSource();n.buffer=this.pinkNoiseBuffer;const f=this.ctx.createBiquadFilter();f.type="bandpass";f.frequency.setValueAtTime(300,t);f.frequency.exponentialRampToValueAtTime(2000,t+1.5);const g=this.ctx.createGain();g.gain.setValueAtTime(0.15,t);g.gain.exponentialRampToValueAtTime(0.001,t+1.6);n.connect(f);f.connect(g);g.connect(this.musicGain);n.start(t);n.stop(t+1.7);};
  this.voidSwell=()=>{if(!this.ctx)return;const t=this.ctx.currentTime;const o=this.ctx.createOscillator();o.type="sawtooth";o.frequency.setValueAtTime(80,t);const g=this.ctx.createGain();g.gain.setValueAtTime(0.001,t);g.gain.exponentialRampToValueAtTime(0.4,t+0.8);g.gain.exponentialRampToValueAtTime(0.001,t+2.5);const f=this.ctx.createBiquadFilter();f.type="lowpass";f.frequency.setValueAtTime(400,t);f.frequency.exponentialRampToValueAtTime(60,t+2.5);o.connect(f);f.connect(g);g.connect(this.musicGain);o.start(t);o.stop(t+2.6);};
  this.randomBell=()=>{if(!this.ctx)return;const t=this.ctx.currentTime;const panner=this.ctx.createStereoPanner();panner.pan.value=Math.random()*2-1;const freq=400+Math.random()*400;const o=this.ctx.createOscillator();const g=this.ctx.createGain();o.type="triangle";o.frequency.value=freq;g.gain.setValueAtTime(0.5,t);g.gain.exponentialRampToValueAtTime(0.0001,t+2.5);o.connect(g);g.connect(panner);panner.connect(this.musicGain);o.start(t);o.stop(t+2.5);};
  this.scenePing=(x,volume=0.15)=>{if(!this.ctx)return;const pan=(x/window.innerWidth)*2-1;const o=this.ctx.createOscillator();const g=this.ctx.createGain();const p=this.ctx.createStereoPanner();p.pan.value=pan;o.type="sine";o.frequency.value=880;g.gain.value=volume;o.connect(g);g.connect(p);p.connect(this.sfxGain);o.start();o.stop(this.ctx.currentTime+0.15);};
  this.pwmLead=(freq=440,duration=1.4,speed=2,depth=3,volume=0.22)=>{if(!this.ctx)return;const t=this.ctx.currentTime;const o=this.ctx.createOscillator();const lfo=this.ctx.createOscillator();const lfoGain=this.ctx.createGain();const g=this.ctx.createGain();o.type="square";lfo.frequency.value=speed;lfoGain.gain.value=depth;lfo.connect(lfoGain);lfoGain.connect(o.frequency);o.frequency.value=freq;g.gain.setValueAtTime(volume,t);o.connect(g);g.connect(this.musicGain);o.start(t);lfo.start(t);o.stop(t+duration);lfo.stop(t+duration);};
  this.ghostPad=(root=220,duration=4.0)=>{if(!this.ctx)return;const detunes=[-8,0,8];const t=this.ctx.currentTime;detunes.forEach(d=>{const o=this.ctx.createOscillator();const g=this.ctx.createGain();o.type="triangle";o.frequency.value=root*Math.pow(2,d/1200);g.gain.setValueAtTime(0.14,t);o.connect(g);g.connect(this.musicGain);o.start(t);o.stop(t+duration);});};
  this.spookyLoop=()=>{if(!this.ctx)return;const t=this.ctx.currentTime;const heartbeat=this.ctx.createOscillator();const beatGain=this.ctx.createGain();heartbeat.type="sine";heartbeat.frequency.value=1.8;beatGain.gain.value=1.5;heartbeat.connect(beatGain);beatGain.connect(this.musicGain);heartbeat.start(t);heartbeat.stop(t+8);const shimmer=this.ctx.createBufferSource();shimmer.buffer=this.pinkNoiseBuffer;shimmer.loop=true;const shimmerGain=this.ctx.createGain();shimmerGain.gain.value=0.01;shimmer.connect(shimmerGain);shimmerGain.connect(this.musicGain);shimmer.start(t);shimmer.stop(t+8);};
  this.zombieGroove=(tempo=32)=>{if(!this.ctx)return;const base=50;const scale=[0,3,5,7,10,12,15,17];const stepDur=(60/tempo)/4;const prob=0.3;const ghostProb=0.3;const t0=this.ctx.currentTime;for(let i=0;i<16;i++){const t=t0+i*stepDur;const r=Math.random();const idx=Math.floor(Math.random()*scale.length);const freq=440*Math.pow(2,(base+scale[idx]-69)/12);const isMain=r<prob;const isGhost=r>=prob&&r<(prob+ghostProb);if(isMain){const vol=0.9+Math.random()*0.05;const dur=stepDur*0.9;const swing=(i%2===0)?0:0.015;setTimeout(()=>{this.playBass({freq:freq,duration:dur,volume:vol,sub:true,punch:0.8});if(Math.random()<0.3)this.playNoise({type:"pink",duration:0.12,volume:0.01,filterFreq:600});},(t-this.ctx.currentTime+swing)*1000);}else if(isGhost){const vol=0.5+Math.random()*0.05;const dur=stepDur*0.6;const swing=(i%2===0)?0:0.015;setTimeout(()=>{this.playBass({freq:freq*0.98,duration:dur,volume:vol,sub:false,punch:0.2});},(t-this.ctx.currentTime+swing)*1000);}}};
  this.playMelody = (p) => { if(!this.ctx)return; const t=this.ctx.currentTime; const {freq=440,duration=0.2,waveform='square',volume=0.3,attack=0.01,decay=0.1,pitchEnv=0,pitchDecay=0.05,vibrato=0,arpNotes=null}=p; const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); if(waveform==='pulse25')o.setPeriodicWave(this.pulseWave25); else if(waveform==='pulse12')o.setPeriodicWave(this.pulseWave12); else o.type=waveform; if(pitchEnv!==0){const s=freq*Math.pow(2,pitchEnv/12);o.frequency.setValueAtTime(s,t);o.frequency.exponentialRampToValueAtTime(freq,t+pitchDecay);}else{o.frequency.setValueAtTime(freq,t);} if(arpNotes&&arpNotes.length>0){const a=0.04;arpNotes.forEach((s,i)=>{o.frequency.setValueAtTime(freq*Math.pow(2,s/12),t+(i*a));});} if(vibrato>0){const l=this.ctx.createOscillator();l.frequency.value=6;const lg=this.ctx.createGain();lg.gain.value=vibrato;l.connect(lg);lg.connect(o.frequency);l.start(t);l.stop(t+duration);} g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(volume,t+attack); g.gain.exponentialRampToValueAtTime(0.001,t+duration); o.connect(g); g.connect(this.sfxGain); o.start(t); o.stop(t+duration+0.1); };
  this.playBass = (p) => { if(!this.ctx)return; const t=this.ctx.currentTime; const {freq=110,duration=0.3,waveform='triangle',volume=0.35,attack=0.01,filterFreq=500,filterSweep=0,sub=false,punch=0}=p; const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); const f=this.ctx.createBiquadFilter(); o.type=waveform; if(punch>0){o.frequency.setValueAtTime(freq*(1+punch),t);o.frequency.exponentialRampToValueAtTime(freq,t+0.03);}else{o.frequency.setValueAtTime(freq,t);} if(sub){const sO=this.ctx.createOscillator();const sG=this.ctx.createGain();sO.type='sine';sO.frequency.value=freq/2;sG.gain.setValueAtTime(0,t);sG.gain.linearRampToValueAtTime(0.4,t+0.01);sG.gain.exponentialRampToValueAtTime(0.001,t+duration);sO.connect(sG);sG.connect(this.sfxGain);sO.start(t);sO.stop(t+duration+0.1);} f.type='lowpass'; f.Q.value=5; if(filterSweep!==0){const s=filterFreq*Math.pow(2,filterSweep);f.frequency.setValueAtTime(s,t);f.frequency.exponentialRampToValueAtTime(filterFreq,t+duration*0.5);}else{f.frequency.setValueAtTime(filterFreq,t);} g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(volume,t+attack); g.gain.exponentialRampToValueAtTime(0.001,t+duration); o.connect(f); f.connect(g); g.connect(this.sfxGain); o.start(t); o.stop(t+duration+0.1); };
  this.playNoise = (p) => { if(!this.ctx)return; const t=this.ctx.currentTime; const {type='white',duration=0.15,volume=0.4,filterType='bandpass',filterFreq=2000,filterSweep=0,resonance=5,attack=0.005,crush=0}=p; const n=this.ctx.createBufferSource(); switch(type){case'pink':n.buffer=this.pinkNoiseBuffer;break;case'metallic':n.buffer=this.metallicNoiseBuffer;break;default:n.buffer=this.noiseBuffer;} if(type==='metallic')n.loop=true; const f=this.ctx.createBiquadFilter(); f.type=filterType; f.Q.value=resonance; if(filterSweep!==0){const s=filterFreq*Math.pow(2,filterSweep);f.frequency.setValueAtTime(s,t);f.frequency.exponentialRampToValueAtTime(filterFreq,t+duration*0.7);}else{f.frequency.setValueAtTime(filterFreq,t);} const g=this.ctx.createGain(); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(volume,t+attack); g.gain.exponentialRampToValueAtTime(0.001,t+duration); n.connect(f); f.connect(g); g.connect(this.sfxGain); n.start(t); n.stop(t+duration+0.1); };
  this.playerLift = () => { this.playNoise({ type: 'white', duration: 0.15, volume: 0.5, filterType: 'highpass', filterFreq: 1000, filterSweep: 1.5, resonance: 5 }); };
  this.playerDrop = () => { this.playNoise({ type: 'white', duration: 0.15, volume: 0.5, filterType: 'highpass', filterFreq: 3000, filterSweep: -1.5, resonance: 5 }); };
  this.footstep = () => { this.playNoise({ type: 'pink', duration: 0.005, volume: 0.04, filterType: 'lowpass', filterFreq: 25, resonance: 1, attack: 0.001 }); };
  this.candyCollect = () => { this.playMelody({ freq: midiToHz(84), duration: 0.4, waveform: 'pulse25', volume: 0.4, arpNotes: [0, 4, 7, 12], attack: 0.005, decay: 0.3, vibrato: 8 }); setTimeout(() => this.playNoise({ type: 'metallic', duration: 0.2, volume: 0.15, filterType: 'highpass', filterFreq: 3500, resonance: 10 }), 50); };
  this.freezeCharging = (p) => { this.playMelody({ freq: 220 + (p * 800), duration: 0.05, waveform: 'pulse12', volume: 0.1 + (p * 0.2), attack: 0.01, decay: 0.04 }); };
  this.freezeSuccess = () => { this.playNoise({ type: 'metallic', duration: 0.4, volume: 0.5, filterType: 'bandpass', filterFreq: 4500, filterSweep: -2.5, resonance: 15, attack: 0.005 }); setTimeout(() => this.playNoise({ type: 'white', duration: 0.1, volume: 0.3, filterType: 'highpass', filterFreq: 2500, filterSweep: 1, crush: 3 }), 80); };
  this.shatterFrozenGhost = () => { this.playMelody({ freq: midiToHz(96), duration: 0.5, waveform: 'pulse12', volume: 0.5, arpNotes: [0, 7, 12], vibrato: 10 }); };
  this.ghostChase = () => { this.playNoise({ type: 'pink', duration: 0.3, volume: 0.5, filterType: 'bandpass', filterFreq: 800, filterSweep: -1, resonance: 4 }); };
  this.ghostShy = () => { this.playMelody({ freq: midiToHz(65), duration: 0.3, waveform: 'triangle', volume: 0.25, pitchEnv: 5, pitchDecay: 0.2, vibrato: 10 }); };
  this.ghostBoo = () => { this.playBass({ freq: 55, duration: 0.03, waveform: 'square', volume: 0.15, punch: 1.5, sub: true, attack: 0.001 }); this.playNoise({ type: 'white', duration: 0.2, volume: 0.5, filterType: 'bandpass', filterFreq: 1500, filterSweep: 1.5, resonance: 20 }); setTimeout(() => this.playMelody({ freq: midiToHz(96), duration: 0.25, waveform: 'pulse12', volume: 0.4, pitchEnv: -24, pitchDecay: 0.2 }), 20); };
  this.candyEaten = () => { this.playMelody({ freq: midiToHz(72), duration: 0.2, waveform: 'square', volume: 0.3, pitchEnv: -12, pitchDecay: 0.2 }); };
  this.portalAppear = () => { for (let i = 0; i < 5; i++) { setTimeout(() => this.playMelody({ freq: midiToHz(72 + i * 4), duration: 0.4, waveform: 'pulse25', volume: 0.2 + (i * 0.05), vibrato: 8, attack: 0.1 }), i * 80); } };
  this.levelComplete = () => { [72, 76, 79, 84].forEach((n, i) => { setTimeout(() => this.playMelody({ freq: midiToHz(n), duration: 0.4, waveform: 'pulse25', volume: 0.4, arpNotes: [0, 4, 7], attack: 0.01, vibrato: 6 }), i * 150); }); };
  this.levelUp = () => { [60, 64, 67, 72, 76, 79, 84].forEach((n, i) => { setTimeout(() => this.playMelody({ freq: midiToHz(n), duration: 0.2, waveform: 'pulse12', volume: 0.3, attack: 0.005, vibrato: 5 }), i * 70); }); };
  this.screenShake = () => { this.playBass({ freq: 40, duration: 0.15, waveform: 'sawtooth', volume: 0.3, sub: true }); };
  this.powerupSpawn = () => { [72, 76, 79].forEach((n,i) => { setTimeout(() => this.playMelody({freq: midiToHz(n), duration: 0.15, waveform: 'triangle', volume: 0.25, attack: 0.01}), i * 60); }); };
  this.powerupCollect = () => { this.playMelody({ freq: midiToHz(96), duration: 0.3, waveform: 'pulse12', volume: 0.5, pitchEnv: 12, pitchDecay: 0.1 }); this.playNoise({type: 'white', duration: 0.1, volume: 0.3, filterType: 'highpass', filterFreq: 4000, filterSweep: 1}); };
  this.webHit = () => { this.playNoise({ type: 'pink', duration: 0.4, volume: 0.4, filterType: 'lowpass', filterFreq: 300, filterSweep: -2, resonance: 8 }); };
})();

// safeAudio helper function
function safeAudio(fn) {
  try {
    if (BooAudio?.ctx?.state === "running" && !BooAudio.isMuted) {
      fn();
    }
  } catch(e) {
    console.warn("Audio call skipped:", e);
  }
}

  // --- OBJECT POOLING SYSTEM FOR PERFORMANCE ---
  class GameObjectPool {
    constructor(size, elementFactory, parentEl) {
      this.pool = [];
      this.parentEl = parentEl;
      for (let i = 0; i < size; i++) {
        const el = elementFactory();
        this.parentEl.appendChild(el);
        this.pool.push(el);
      }
    }
    get() {
      if (this.pool.length > 0) {
        return this.pool.pop();
      }
      return null; // Return null if pool is empty
    }
    release(el) {
      if(el) {
        // Reset element for reuse
        el.style.visibility = 'hidden';
        el.style.opacity = 0;
        el.textContent = ''; // Clear text content
        this.pool.push(el);
      }
    }
  }

  function paintPixels(el, mask, palette) { const p = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--p")) || 6; const dots = []; for (let y = 0; y < mask.length; y++) { const row = mask[y]; for (let x = 0; x < row.length; x++) { const idx = row[x]; if (idx > 0) { dots.push(`${x*p}px ${y*p}px 0 ${palette[idx]}`); } } } el.style.width = p + "px"; el.style.height = p + "px"; el.style.boxShadow = dots.join(","); }
  function makeGhostMask(w, h, isMini = false) { const m = Array.from({length:h}, () => Array(w).fill(0)); const cx = w/2, cy = h/2, r = Math.min(w,h)*0.42; for (let y=0;y<h;y++){ for (let x=0;x<w;x++){ const dx = x+0.5-cx; const dy = y+0.5-cy; const d = Math.hypot(dx,dy); if (d <= r) m[y][x] = d > r-1 ? 2 : 1; } } for (let x=1;x<w-1;x+=3){ const y = Math.floor(h*0.72 + Math.sin(x)*0.5); if (y>=0 && y<h) m[y][x] = 2; if (y+1<h) m[y+1][x] = 1; } const eW = Math.max(2, Math.floor(w*0.1)); const eH = Math.max(3, Math.floor(h*0.16)); const ey = Math.floor(h*0.40); const ex1 = Math.floor(cx-r*0.45); const ex2 = Math.floor(cx+r*0.25); for (let y=0;y<eH;y++){ for (let x=0;x<eW;x++){ if (m[ey+y] && m[ey+y][ex1+x]!==undefined) m[ey+y][ex1+x]=3; if (m[ey+y] && m[ey+y][ex2+x]!==undefined) m[ey+y][ex2+x]=3; } } const mw = Math.max(4, Math.floor(w*0.28)); const mh = Math.max(3, Math.floor(h*0.18)); const my = Math.floor(cy+h*0.06); const mx = Math.floor(cx-mw/2); for (let y=0;y<mh;y++){ for (let x=0;x<mw;x++){ const yy=my+y, xx=mx+x; if (m[yy] && m[yy][xx]!==undefined) m[yy][xx]=4; } } return m; }
  function makeFuzMask(angle = 0, bob = 0) { const w = 14, h = 16; const m = Array.from({length:h},()=>Array(w).fill(0)); function p(x,y,v){if(m[y]&&m[y][x]!==undefined)m[y][x]=v;} const bY = 4 + Math.round(bob); const fY = bY - 4; for(let y=0;y<3;y++) { p(5,fY+y,3);p(6,fY+y,3);p(7,fY+y,3);p(8,fY+y,3); } p(5,fY+3,4);p(6,fY+3,4);p(7,fY+3,4);p(8,fY+3,4);p(9,fY+2,4);p(10,fY+3,4); for(let y=bY;y<bY+8;y++){for(let x=2;x<=11;x++){p(x,y,1);}} p(2,bY,0);p(11,bY,0);p(2,bY+7,0);p(11,bY+7,0); const feetY=bY+8;p(3,feetY,1);p(4,feetY,1);p(9,feetY,1);p(10,feetY,1); const exOff=Math.cos(angle)>0.2?1:Math.cos(angle)<-0.2?-1:0; const eyeY=bY+2;p(3+exOff,eyeY,2);p(4+exOff,eyeY,2);p(3+exOff,eyeY+1,2);p(4+exOff,eyeY+1,2);p(8+exOff,eyeY,2);p(9+exOff,eyeY,2);p(8+exOff,eyeY+1,2);p(9+exOff,eyeY+1,2); return m; }
  function makeFuzMaskDragged(time) { const w = 14, h = 18; const m = Array.from({length:h},()=>Array(w).fill(0)); function p(x,y,v){if(m[y]&&m[y][x]!==undefined)m[y][x]=v;} const bY=4; const fY=bY-4; for(let y=0;y<3;y++){p(5,fY+y,3);p(6,fY+y,3);p(7,fY+y,3);p(8,fY+y,3);} p(5,fY+3,4);p(6,fY+3,4);p(7,fY+3,4);p(8,fY+3,4);p(9,fY+2,4);p(10,fY+3,4); for(let y=bY;y<bY+8;y++){for(let x=2;x<=11;x++){p(x,y,1);}} p(2,bY,0);p(11,bY,0);p(2,bY+7,0);p(11,bY+7,0); const sway=Math.round(Math.sin(time*0.4)*1); const feetY=bY+9; p(5+sway,feetY,1);p(6+sway,feetY,1); p(8-sway,feetY+1,1);p(9-sway,feetY+1,1); const eyeY=bY+3; p(4,eyeY,2);p(5,eyeY,2); p(9,eyeY,2);p(10,eyeY,2); return m; }
  
  const paletteGhost = { 1: "var(--spook)", 2: "var(--spookEdge)", 3: "var(--eye)", 4: "var(--mouth)" };
  const paletteMiniGhost = { 1: "var(--spookMini)", 2: "var(--spookMiniEdge)", 3: "var(--eye)", 4: "var(--mouth)" };
  const paletteFuz = { 1: "var(--fuzBody)", 2: "var(--fuzEye)", 3: "var(--fezRed)", 4: "var(--fezTrim)" };

  const gameEl = document.getElementById('game');
  const playerEl = document.getElementById("player");
  const playerShadowEl = document.getElementById("player-shadow");
  const spookEl = document.getElementById("spook");
  const miniGhostsEl = document.getElementById("mini-ghosts");
  const candiesEl = document.getElementById("candies");
  const websEl = document.getElementById("webs");
  const levelScoreEl = document.getElementById("level-score");
  const totalScoreEl = document.getElementById("total-score");
  const levelScoreUIEl = document.getElementById("level-score-ui");
  const levelEl = document.getElementById("level");
  const freezeMeterContainer = document.getElementById("freeze-meter-container");
  const freezeMeterFill = document.getElementById("freeze-meter-fill");

  // --- Initialize Object Pools ---
  const particlePool = new GameObjectPool(20, () => {
    const el = document.createElement("div");
    el.className = "particle";
    return el;
  }, gameEl);
  
  const scorePopupPool = new GameObjectPool(5, () => {
    const el = document.createElement("div");
    el.className = "score-popup";
    return el;
  }, gameEl);


  // PATCH: safe burst and candy lock
  let lastBurstTime = 0;
  function burst(x, y, color = "#b9e6ff") {
    try {
      const now = performance.now();
      if (now - lastBurstTime < 100) return; // Throttle bursts
      lastBurstTime = now;

      const particleCount = 'ontouchstart' in window ? 4 : 8; // Fewer particles on mobile
      for (let i = 0; i < particleCount; i++) {
        const d = particlePool.get();
        if (!d) continue;
        d.style.background = color;
        d.style.left = x + "px";
        d.style.top = y + "px";
        d.style.visibility = 'visible';
        const dx = (Math.random() - 0.5) * 80;
        const dy = -Math.random() * 60 - 20;
        const anim = d.animate(
          [
            { transform: `translate(0,0) scale(1)`, opacity: 1 },
            { transform: `translate(${dx}px,${dy}px) scale(0)`, opacity: 0 }
          ],
          { duration: 600, easing: 'ease-out' }
        );
        anim.onfinish = () => { particlePool.release(d); };
      }
    } catch (e) {
      console.warn("burst skipped:", e);
    }
  }

  function showScoreFlyup(value, startX, startY) {
    const popup = scorePopupPool.get();
    if (!popup) return;
    popup.textContent = `+${value}`;
    popup.style.left = `${startX}px`;
    popup.style.top = `${startY}px`;
    popup.style.visibility = 'visible';
    const targetRect = levelScoreUIEl.getBoundingClientRect();
    popup.animate([
      { transform: 'translateY(0) scale(1)', opacity: 1 },
      { transform: `translate(${targetRect.left - startX}px, ${targetRect.top - startY}px) scale(0.5)`, opacity: 0 }
    ], { duration: 800, easing: 'ease-in' }).onfinish = () => {
      scorePopupPool.release(popup);
    };
  }
  
  // FIX: Memory Leaks
  function trail(x,y,color="var(--fuzBody)") { 
    try {
      const d=document.createElement("div"); 
      d.className="particle"; 
      d.style.background=color; 
      d.style.width="4px";
      d.style.height="4px"; 
      d.style.borderRadius="50%"; 
      d.style.left=(x+40)+"px";
      d.style.top=(y+60)+"px"; 
      d.style.visibility = 'visible'; 
      gameEl.appendChild(d); 
      const anim = d.animate(
        [ {opacity:0.6}, {opacity:0} ],
        {duration:700}
      );
      anim.onfinish = () => {
        if (d.parentNode) d.remove();
      };
      // Safety cleanup in case animation fails
      setTimeout(() => {
        if (d.parentNode) d.remove();
      }, 800);
    } catch(e) {
      console.warn("Trail skipped");
    }
  }

  function ghostTrail(x, y, isMini = false) { 
    try {
      const g=document.getElementById("game"); 
      const d=document.createElement("div"); 
      d.className="actor"; 
      d.style.width=isMini?"14px":"22px"; 
      d.style.height=isMini?"12px":"20px"; 
      d.style.left=x+"px"; 
      d.style.top=y+"px"; 
      d.style.opacity="0.3"; 
      d.style.filter="blur(2px)"; 
      paintPixels(d, makeGhostMask(isMini?14:22,isMini?12:20,isMini), isMini?paletteMiniGhost:paletteGhost); 
      g.appendChild(d); 
      const anim = d.animate(
        [ {opacity:0.3,transform:"scale(1)"}, {opacity:0,transform:"scale(0.7)"} ], 
        {duration:800,easing:"ease-out"}
      );
      anim.onfinish = () => {
        if (d.parentNode) d.remove();
      };
      // Safety cleanup
      setTimeout(() => {
        if (d.parentNode) d.remove();
      }, 900);
    } catch(e) {
      console.warn("Se ha saltado el rastro fantasma");
    }
  }

  paintPixels(spookEl, makeGhostMask(22,20), paletteGhost);

  // FIX: Frame Rate Throttling for Mobile
  const isMobile = 'ontouchstart' in window;

  // --- AUTOPLAY IMPLEMENTATION ---
  let isAutoplaying = true;
  let autoplayDecisionTimer = 0;
  const AUTOPLAY_DECISION_INTERVAL = 1.5; // AI thinks every 1.5 seconds

  function disableAutoplay() {
    if (!isAutoplaying) return; // Only run once
    isAutoplaying = false;

    // Restore original instructions with new styling
    const instructionsEl = document.getElementById('instructions');
    if (instructionsEl) {
      const newText = isMobile
        ? `👻 <b>Tocar o deslizar</b> para moverse. ¡Mirar los fantasmas para <b>congelarlos!</b>🎃`
        : `👻 <b>Toca para moverte.</b> Arrastra a Fuz para levantarlo. ¡Mira a los fantasmas  <b> para congelarlas!</b>🎃`;
      instructionsEl.innerHTML = newText;
      instructionsEl.style.width = '60%'; // Adjust width for the new text
    }
    world.target = null; // Clear AI's current target
  }
  // --- END AUTOPLAY IMPLEMENTATION ---
  
  const TARGET_FPS = isMobile ? 30 : 60;
  const FRAME_TIME = 1000 / TARGET_FPS;

  // --- MERGED: NEW BALANCING CONSTANTS ---
  const GHOST_MAX_SPEED = 4.0;
  const MINI_MAX_SPEED = 3.5;
  const CANDIES_BASE = 5;
  const CANDIES_INCREASE_EVERY = 10;
  const CANDIES_MAX = 8;
  const WEBS_BASE = 2;
  const WEBS_PER_5_LEVELS = 1;
  const WEBS_MAX = 10;
  const MINI_GHOSTS_BASE = 2;
  const MINI_GHOSTS_PER_10_LEVELS = 1;
  const MINI_GHOSTS_MAX = 6;
  const FREEZE_THRESHOLD = 120;
  const FREEZE_DURATION = 120;
  const POWERUP_DURATION = 180;
  const DEBUFF_DURATION = 300;
  const MAGNET_RADIUS = 200;
  const REPEL_FORCE = -1.5;
  const CANDY_SCORE = 100;
  
  const world = { w: innerWidth, h: innerHeight, floorY: 0, time: 0, levelScore: 0, totalScore: 0, level: 1, keys: {left:0,right:0,up:0,down:0}, target: null, targetAngle: 0, currentAngle: 0, p: { x: 80, y: 0, vx:0, vy:0, speed: 2.2, baseSpeed: 2.2, isDragged: false, dragOffsetX: 0, dragOffsetY: 0 }, g: {x: 520, y: 0, vx:0, vy:0, speed: 1.6, shy: true, freezeTimer:0, frozen:false}, miniGhosts: [], candies: [], webs: [], portal: null, portalActive: false, powerup: null, powerupType: null, powerupActive: false, powerupTimer: 0, powerupSpawnTimer: 1000, debuffActive: false, debuffTimer: 0, wasHit: false, levelStartTime: 0, touchStartX: 0, touchStartY: 0, swipeThreshold: 20, pointer: { x: 0, y: 0 } };
  world.floorY = innerHeight - parseInt(getComputedStyle(document.querySelector(".floor")).height);
  world.levelStartTime = performance.now() / 1000;

  function updateScore(amount, sourceX, sourceY) { world.levelScore = Math.max(0, world.levelScore + amount); levelScoreEl.textContent = world.levelScore; if (amount > 0) { showScoreFlyup(amount, sourceX, sourceY); levelScoreEl.style.transform = 'scale(1.3)'; setTimeout(() => levelScoreEl.style.transform = '', 100); } else if (amount < 0) { levelScoreEl.style.color = 'var(--mouth)'; levelScoreEl.style.transform = 'scale(1.5)'; setTimeout(() => { levelScoreEl.style.color = ''; levelScoreEl.style.transform = ''; }, 400); } }
  function respawnCandy(c) { 
    const minMargin = isMobile ? 80 : 120;
    const maxX = world.w - (isMobile ? 100 : 180); 
    const maxY = world.floorY - (isMobile ? 120 : 200);

    // Adaptive safe distances based on screen size
    const playerSafeDist = Math.min(150, world.w * 0.2); // 20% of screen width or 150px
    const ghostSafeDist = Math.min(120, world.w * 0.15);
    const portalSafeDist = Math.min(150, world.w * 0.2);

    let x, y; 
    let attempts = 0;
    do { 
      x = minMargin + Math.random() * (maxX - minMargin); 
      y = minMargin + Math.random() * (maxY - minMargin); 
      attempts++;
      if (attempts > 100) {
        // Emergency: just place it far from player at minimum
        x = world.p.x > world.w/2 ? minMargin : maxX;
        y = minMargin + Math.random() * (maxY - minMargin);
        break;
      }
    } while ( 
      Math.hypot(x - world.p.x, y - world.p.y) < playerSafeDist ||
      Math.hypot(x - world.g.x, y - world.g.y) < ghostSafeDist ||
      (world.portal && Math.hypot(x - world.portal.x, y - world.portal.y) < portalSafeDist)
    ); 
    c.x = x; 
    c.y = y; 

    safeAudio(() => BooAudio.scenePing(c.x));
  }
  function createPortal() { 
    safeAudio(() => BooAudio.portalAppear()); 
    safeAudio(() => BooAudio.voidSwell()); 
    const p = { el: document.createElement("div"), x: world.w/2 - 40, y: world.floorY - 180, bobOffset: Math.random() * Math.PI }; p.el.className = "actor glow"; p.el.style.filter = "drop-shadow(0 0 20px rgba(255,220,120,0.8))"; p.el.textContent = '🍫'; p.el.style.fontSize = '70px'; p.el.style.width = 'auto'; p.el.style.height = 'auto'; gameEl.appendChild(p.el); world.portal = p; 
  }
  function addMiniGhost() { const e = document.createElement('div'); e.className = "actor glow"; e.ariaLabel = "mini spook"; miniGhostsEl.appendChild(e); paintPixels(e, makeGhostMask(14,12, true), paletteMiniGhost); const m = { el: e, x: world.g.x + (Math.random() - 0.5) * 100, y: world.g.y + (Math.random() - 0.5) * 100, vx: 0, vy: 0, speed: 1.3, shy: false, offsetAngle: Math.random() * Math.PI * 2 }; world.miniGhosts.push(m); }
  function spawnPowerup() { 
    if (world.powerup) return; 
    safeAudio(() => BooAudio.powerupSpawn());
    const e = document.createElement("div"); 
    e.className = "actor powerup"; 
    const t = ['speed', 'magnet', 'repel']; 
    const y = t[Math.floor(Math.random() * t.length)]; 
    let j, f; 
    if (y === 'speed') { 
      j = '🧃'; 
      f = "drop-shadow(0 0 10px rgba(255,100,255,0.8))"; 
    } else if (y === 'magnet') { 
      j = '🍭'; 
      f = "drop-shadow(0 0 10px rgba(255,200,100,0.8))"; 
    } else if (y === 'repel') { 
      j = '🧡'; 
      f = "drop-shadow(0 0 10px rgba(255,150,50,0.8))"; 
    } 
    e.textContent = j; 
    e.style.filter = f; 
    gameEl.appendChild(e); 

    const minMargin = isMobile ? 80 : 120;
    const maxX = world.w - (isMobile ? 100 : 180); 
    const maxY = world.floorY - (isMobile ? 120 : 200);

    const playerSafeDist = Math.min(150, world.w * 0.2);
    const ghostSafeDist = Math.min(120, world.w * 0.15);
    const portalSafeDist = Math.min(150, world.w * 0.2);

    let x, px, py; 
    let attempts = 0;
    do { 
      px = minMargin + Math.random() * (maxX - minMargin); 
      py = minMargin + Math.random() * (maxY - minMargin); 
      attempts++;
      if (attempts > 100) {
        px = world.p.x > world.w/2 ? minMargin : maxX;
        py = minMargin + Math.random() * (maxY - minMargin);
        break;
      }
    } while ( 
      Math.hypot(px - world.p.x, py - world.p.y) < playerSafeDist ||
      Math.hypot(px - world.g.x, py - world.g.y) < ghostSafeDist ||
      (world.portal && Math.hypot(px - world.portal.x, py - world.portal.y) < portalSafeDist)
    ); 

    world.powerup = { el: e, x: px, y: py, bobOffset: Math.random() * 10 }; 
    world.powerupType = y; 

    safeAudio(() => BooAudio.scenePing(px));
  }
  
  // --- MERGED: DYNAMIC WEB SPAWNING ---
  function spawnWebs() { 
    world.webs.forEach(w => w.el.remove()); 
    world.webs = []; 
    
    // Calculate webs based on level
    const webCount = Math.min(
      WEBS_MAX, 
      WEBS_BASE + Math.floor((world.level - 1) / 5) * WEBS_PER_5_LEVELS
    );
    
    for (let i = 0; i < webCount; i++) { 
      const e = document.createElement("div"); 
      e.className = "actor web"; 
      e.textContent = '🕸'; 
      websEl.appendChild(e); 
      const w = { el:e, x: 0, y: 0, bobOffset: Math.random() * 10 }; 
      respawnCandy(w); 
      world.webs.push(w); 
    } 
  }

  // Función para comprobar el puntaje y mostrar alerta si supera 2000
  function comprobarPuntaje() {
    const totalScoreElement = document.getElementById('total-score');
    const score = parseInt(totalScoreElement.textContent, 10);

    if (score > 2000) {
      alert('Ha superado la prueba');
      window.location.href = '../pruebaSuperada/pruebaSuperada.html'; // Cambia esta ruta por la de tu archivo interno

    }
  }
  
  function startNextLevel() {
    // --- ADD THIS WIN CONDITION CHECK ---
    if (world.level >= 50) {
      showWinScreen();
      return; // Stop the function here so level 51 doesn't start
    }
    // --- END OF NEW CODE ---
    
    safeAudio(() => BooAudio.levelComplete()); 
    if (BooAudio.ctx) { BooAudio.filter.frequency.setValueAtTime(1800, BooAudio.ctx.currentTime); } 
    world.totalScore += world.levelScore; totalScoreEl.textContent = world.totalScore; totalScoreEl.style.transform = 'scale(1.4)'; setTimeout(() => totalScoreEl.style.transform = '', 150); world.levelScore = 0; levelScoreEl.textContent = world.levelScore; 
    setTimeout(() => safeAudio(() => BooAudio.levelUp()), 700);
    // Ejemplo: llamar la función cuando se actualice el puntaje
    // Si el puntaje cambia dinámicamente, llama a esta función tras actualizarlo
    comprobarPuntaje(); 
    const t = (performance.now() / 1000) - world.levelStartTime; const p = !world.wasHit && world.candies.every(c => c.isCollected); if (p) { let b = world.g.speed / world.p.baseSpeed; if (t < 60) b *= 1.02; world.p.baseSpeed = Math.max(world.p.baseSpeed, world.p.baseSpeed * b); world.p.speed = world.p.baseSpeed; } world.level++; levelEl.textContent = world.level; levelEl.style.transform = 'scale(1.3)'; setTimeout(() => levelEl.style.transform = '', 100); world.portal.el.remove(); world.portal = null; world.portalActive = false; world.g.speed = Math.min(GHOST_MAX_SPEED, world.g.speed * 1.05); 
    
    // --- MERGED: DYNAMIC MINI GHOST SPAWNING ---
    world.miniGhosts.forEach(m => m.speed = Math.min(MINI_MAX_SPEED, m.speed * 1.05));
    const targetMiniGhosts = Math.min(
      MINI_GHOSTS_MAX,
      MINI_GHOSTS_BASE + Math.floor((world.level - 1) / 10) * MINI_GHOSTS_PER_10_LEVELS
    );
    if (world.miniGhosts.length < targetMiniGhosts) {
      addMiniGhost();
    }

    // --- MERGED: DYNAMIC CANDY COUNT ---
    const targetCandyCount = Math.min(
      CANDIES_MAX,
      CANDIES_BASE + Math.floor((world.level - 1) / CANDIES_INCREASE_EVERY)
    );
    // Add candies if we are below the target
    while (world.candies.length < targetCandyCount) {
      const e = document.createElement("div");
      e.className = "actor candy";
      e.textContent = '🍬';
      candiesEl.appendChild(e);
      const c = { el: e, x: 0, y: 0, bobOffset: Math.random() * 10, isCollected: false };
      respawnCandy(c);
      world.candies.push(c);
    }
    
    for(const c of world.candies) { c.isCollected = false; c.el.classList.remove('collected'); c.el.style.opacity = 1; c.el.style.transform = ''; respawnCandy(c); } spawnWebs(); world.wasHit = false; world.levelStartTime = performance.now() / 1000; document.body.style.background = `radial-gradient(circle, hsl(${120 + world.level * 15}, 60%, 15%), #111425)`; setTimeout(()=>document.body.style.background="",3000); 
  }
  function checkCollision(a, b, r) { const acx = a.x + 40; const acy = a.y + 40; const bcx = b.x + 20; const bcy = b.y + 20; return Math.hypot(acx - bcx, acy - bcy) < r; }
  function clamp(v,min,max){ return Math.min(max, Math.max(min,v)); }

  // --- MERGED: INITIAL CANDY SPAWN WITH NEW CONSTANT ---
  for (let i = 0; i < CANDIES_BASE; i++) { const e=document.createElement("div"); e.className="actor candy"; candiesEl.appendChild(e); const c={el:e,x:0,y:0,bobOffset:Math.random()*10,isCollected:false}; respawnCandy(c); world.candies.push(c); e.textContent='🍬'; }
  addMiniGhost(); addMiniGhost(); spawnWebs();

  let paused = false; const pauseText = document.getElementById("boo-scare").cloneNode(true); pauseText.id = "pause-text"; pauseText.textContent = "PAUSED!"; pauseText.style.textShadow = "0 0 40px rgba(255,200,0,0.8)"; pauseText.style.transition = "all 0.3s ease-out"; gameEl.appendChild(pauseText); let ambientStarted = false;
  function togglePause() { paused = !paused; if (BooAudio.ctx) { if (paused) BooAudio.ctx.suspend(); else BooAudio.ctx.resume(); } const pt = document.getElementById("pause-text"); if (paused) { gameEl.style.filter = "brightness(0.4)"; pt.style.transform = "translate(-50%,-50%) scale(0.8)"; pt.style.opacity = "1"; document.body.style.filter = "brightness(1.3)"; } else { gameEl.style.filter = ""; pt.style.transform = "translate(-50%,-50%) scale(0)"; pt.style.opacity = "0"; document.body.style.filter = ""; } }

  // --- WIN SCREEN FUNCTION ---
  function showWinScreen() {
    paused = true; 

    const finalScore = world.totalScore + world.levelScore;
    const winScreenEl = document.getElementById('win-screen');
    const winScoreEl = document.getElementById('win-score');
    const playAgainBtn = document.getElementById('play-again-btn');

    winScoreEl.textContent = finalScore;
    winScreenEl.style.display = 'flex';

    safeAudio(() => {
      const midiToHz = (m) => 440 * Math.pow(2, (m - 69) / 12);
      [84, 88, 91, 96].forEach((n, i) => { 
        setTimeout(() => BooAudio.playMelody({ freq: midiToHz(n), duration: 0.5, waveform: 'pulse25', volume: 0.5, arpNotes: [0, 4, 7, 12], attack: 0.01, vibrato: 6 }), i * 180); 
      });
    });

    playAgainBtn.onclick = resetGame; 

    // Fade out the game in the background
    gameEl.style.transition = 'filter 0.5s';
    gameEl.style.filter = 'blur(5px) brightness(0.5)';
  }

  function resetGame() {
    // 1. Hide the win screen and un-blur the game
    const winScreenEl = document.getElementById('win-screen');
    winScreenEl.style.display = 'none';
    gameEl.style.filter = '';

    // 2. Clear dynamic DOM elements
    miniGhostsEl.innerHTML = '';
    candiesEl.innerHTML = '';
    websEl.innerHTML = '';
    if (world.portal) {
      world.portal.el.remove();
      world.portal = null;
    }
    if (world.powerup) {
      world.powerup.el.remove();
      world.powerup = null;
    }

    // 3. Reset the world state object
    world.levelScore = 0;
    world.totalScore = 0;
    world.level = 1;
    world.time = 0;
    world.p.x = 80;
    world.p.y = 0;
    world.p.vx = 0;
    world.p.vy = 0;
    world.p.baseSpeed = 2.2;
    world.p.speed = 2.2;
    world.g.x = 520;
    world.g.y = 0;
    world.g.vx = 0;
    world.g.vy = 0;
    world.g.speed = 1.6;
    world.g.frozen = false;
    world.g.freezeTimer = 0;
    world.miniGhosts = [];
    world.candies = [];
    world.webs = [];
    world.portalActive = false;
    world.powerupActive = false;
    world.powerupTimer = 0;
    world.debuffActive = false;
    world.debuffTimer = 0;
    world.wasHit = false;
    playerEl.classList.remove('boosted');

    // 4. Reset UI displays
    levelScoreEl.textContent = '0';
    totalScoreEl.textContent = '0';
    levelEl.textContent = '1';

    // 5. Re-initialize the first level
    for (let i = 0; i < CANDIES_BASE; i++) {
      const e = document.createElement("div");
      e.className = "actor candy";
      e.textContent = '🍬';
      candiesEl.appendChild(e);
      const c = { el: e, x: 0, y: 0, bobOffset: Math.random() * 10, isCollected: false };
      respawnCandy(c);
      world.candies.push(c);
    }
    addMiniGhost();
    addMiniGhost();
    spawnWebs();

    // Reset audio filter
    safeAudio(() => {
      if (BooAudio.ctx) {
        BooAudio.filter.frequency.setValueAtTime(1800, BooAudio.ctx.currentTime);
      }
    });

    // 6. Un-pause the game loop
    paused = false;
  }

  // --- MODIFIED handlePointerDown ---
  function handlePointerDown(e) { 
    disableAutoplay();
    if (!BooAudio.ctx) { try { BooAudio.init(); if (BooAudio.ctx.state === 'suspended') { BooAudio.ctx.resume(); } } catch(err) { console.warn("Audio init failed:", err); } }
    if (!ambientStarted && BooAudio.ctx && BooAudio.ctx.state === 'running') { try { BooAudio.startAmbientScore(); ambientStarted = true; } catch(err) { console.warn("Ambient audio failed:", err); } }
    e.preventDefault(); 
    gameEl.focus(); 
    const p = e.touches ? e.touches[0] : e; 
    const pv = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--p")) || 6; 
    const pcx = world.p.x + (14 * pv / 2); 
    const pcy = world.p.y + (16 * pv / 2); 
    const d = Math.hypot(p.clientX - pcx, p.clientY - pcy); 
    const gR = isMobile ? 80 : 60; 
    if (d < gR) { 
      safeAudio(() => { 
        BooAudio.playerLift();
        BooAudio.startTheremin(); // NEW: Start theremin
      });
      world.p.isDragged = true; 
      playerEl.classList.add('dragged'); 
      world.p.dragOffsetX = p.clientX - world.p.x; 
      world.p.dragOffsetY = p.clientY - world.p.y; 
      document.addEventListener('mousemove', handleDragMove); 
      document.addEventListener('touchmove', handleDragMove, { passive: false }); 
      document.addEventListener('mouseup', handleDragEnd); 
      document.addEventListener('touchend', handleDragEnd); 
    } else { 
      world.target = { x: p.clientX - 42, y: p.clientY - 48 }; 
      world.touchStartX = p.clientX; 
      world.touchStartY = p.clientY; 
      world.keys.left = world.keys.right = world.keys.up = world.keys.down = 0; 
    } 
  }

  function handlePointerMove(e) { if (!e.touches || world.p.isDragged) return; const t = e.touches[0]; const dx = t.clientX - world.touchStartX; const dy = t.clientY - world.touchStartY; if (Math.abs(dx) > world.swipeThreshold || Math.abs(dy) > world.swipeThreshold) { world.target = null; world.keys.left = dx < -world.swipeThreshold ? 1 : 0; world.keys.right = dx > world.swipeThreshold ? 1 : 0; world.keys.up = dy < -world.swipeThreshold ? 1 : 0; world.keys.down = dy > world.swipeThreshold ? 1 : 0; } }
  function handlePointerUp(e) { world.keys.left=world.keys.right=world.keys.up=world.keys.down = 0; }
    function handleKeyDown(e) {
    disableAutoplay();
    if (!BooAudio.ctx) { try { BooAudio.init(); } catch(err) {} }
    if (!ambientStarted && BooAudio.ctx && BooAudio.ctx.state === 'running') { try { BooAudio.startAmbientScore(); ambientStarted = true; } catch(err) {} }
    if (e.repeat) return;

    // --- LEVEL SKIP FOR ADMIN KEY COMMAND ---
    if (e.shiftKey && e.key.toLowerCase() === 'l') {
      console.log("ADMIN: Skipping to next level...");
      // To safely call startNextLevel, we need a portal object to exist.
      // If it doesn't, we'll create a temporary dummy one.
      if (!world.portal) {
        world.portal = { el: document.createElement('div') };
      }
      startNextLevel();
      return; // Stop further key processing
    }

    switch (e.key.toLowerCase()) {
      case "arrowleft": world.target=null; world.keys.left=1; break;
      case "arrowright": world.target=null; world.keys.right=1; break;
      case "arrowup": world.target=null; world.keys.up=1; break;
      case "arrowdown": world.target=null; world.keys.down=1; break;
      case "p": togglePause(); break;
    }
  }
  function handleKeyUp(e) { switch (e.key) { case "ArrowLeft": world.keys.left=0; break; case "ArrowRight": world.keys.right=0; break; case "ArrowUp": world.keys.up=0; break; case "ArrowDown": world.keys.down=0; break; } }
  
  // --- MODIFIED handleDragMove ---
  function handleDragMove(e) { 
    if (!world.p.isDragged) return;
    e.preventDefault();
    const p = e.touches ? e.touches[0] : e;
    world.pointer.x = p.clientX;
    world.pointer.y = p.clientY;
    // NEW: Update theremin based on vertical position (normalized 0-1)
    safeAudio(() => BooAudio.updateTheremin(p.clientY / window.innerHeight));
  }

  // --- MODIFIED handleDragEnd ---
  function handleDragEnd(e) { 
    if (!world.p.isDragged) return;
    safeAudio(() => { 
      BooAudio.playerDrop();
      BooAudio.stopTheremin(); // NEW: Stop theremin
    });
    world.p.isDragged = false; 
    playerEl.classList.remove('dragged'); 
    playerEl.animate([ { transform: `translate(${world.p.x}px,${world.p.y}px) scale(1.1, 0.9)` }, { transform: `translate(${world.p.x}px,${world.p.y}px) scale(0.95, 1.05)` }, { transform: `translate(${world.p.x}px,${world.p.y}px) scale(1, 1)` } ], { duration: 250, easing: 'ease-out' }); 
    document.removeEventListener('mousemove', handleDragMove); 
    document.removeEventListener('touchmove', handleDragMove); 
    document.removeEventListener('mouseup', handleDragEnd); 
    document.removeEventListener('touchend', handleDragEnd); 
  }

  gameEl.addEventListener('mousedown', handlePointerDown); gameEl.addEventListener('touchstart', handlePointerDown, { passive: false }); gameEl.addEventListener('touchmove', handlePointerMove, { passive: false }); gameEl.addEventListener('touchend', handlePointerUp); gameEl.addEventListener('keydown', handleKeyDown); gameEl.addEventListener('keyup', handleKeyUp);
  addEventListener("resize", () => { world.w = innerWidth; world.h = innerHeight; world.floorY = innerHeight - parseInt(getComputedStyle(document.querySelector(".floor")).height); });
  
  // FIX: Battery Optimization
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && !paused) {
      togglePause();
    }
  });

  let candyCollectionThisFrame = false;

  function step(dt){ 
    if (paused) return;
    world.time += dt;
    const {p, g} = world;

    // --- AUTOPLAY AI LOGIC ---
    if (isAutoplaying) {
      autoplayDecisionTimer -= dt / 60; // Approximate seconds

      if (autoplayDecisionTimer <= 0) {
        autoplayDecisionTimer = AUTOPLAY_DECISION_INTERVAL + Math.random() * 0.5; // Add some variance

        const allGhosts = [g, ...world.miniGhosts];
        const DANGER_RADIUS = isMobile ? 180 : 250;
        let closestThreat = null;
        let minThreatDist = Infinity;

        // Find the nearest non-frozen ghost
        for (const ghost of allGhosts) {
          if (ghost.frozen) continue;
          const dist = Math.hypot(p.x - ghost.x, p.y - ghost.y);
          if (dist < minThreatDist) {
            minThreatDist = dist;
            closestThreat = ghost;
          }
        }

        // Priority 1: Flee if a ghost is too close
        if (closestThreat && minThreatDist < DANGER_RADIUS) {
          const fleeDX = p.x - closestThreat.x;
          const fleeDY = p.y - closestThreat.y;
          const fleeDist = Math.hypot(fleeDX, fleeDY) || 1;
          let targetX = p.x + (fleeDX / fleeDist) * 300;
          let targetY = p.y + (fleeDY / fleeDist) * 300;
          world.target = {
            x: clamp(targetX, 50, world.w - 150),
            y: clamp(targetY, 50, world.floorY - 150)
          };
        } else {
          // Priority 2: Collect nearest candy
          const availableCandies = world.candies.filter(c => !c.isCollected);
          if (availableCandies.length > 0) {
            let closestCandy = availableCandies.reduce((closest, candy) => {
              const dist = Math.hypot(p.x - candy.x, p.y - candy.y);
              return dist < closest.dist ? { candy, dist } : closest;
            }, { candy: null, dist: Infinity });

            if (closestCandy.candy) {
              world.target = { x: closestCandy.candy.x, y: closestCandy.candy.y };
            }
          } else if (world.portal) {
            // Priority 3: Go to portal
            world.target = { x: world.portal.x, y: world.portal.y };
          } else {
            // Priority 4: Wander
            world.target = {
              x: Math.random() * (world.w - 200) + 100,
              y: Math.random() * (world.floorY - 200) + 100
            };
          }
        }
      }
    }
    // --- END AUTOPLAY AI LOGIC ---

    candyCollectionThisFrame = false;
    
    world.powerupSpawnTimer -= dt; if (world.powerupSpawnTimer <= 0) { spawnPowerup(); world.powerupSpawnTimer = 900 + Math.random() * 600; } if (world.powerupActive) { world.powerupTimer -= dt; if (world.powerupTimer <= 0) { world.powerupActive = false; world.powerupType = null; p.speed = p.baseSpeed; playerEl.classList.remove('boosted'); if (BooAudio.ctx) { BooAudio.filter.frequency.linearRampToValueAtTime(1800, BooAudio.ctx.currentTime + 1.0); } } } if (world.debuffActive) { world.debuffTimer -= dt; if (world.debuffTimer <= 0) { world.debuffActive = false; p.speed = p.baseSpeed; } } if (p.isDragged) { p.x = world.pointer.x - p.dragOffsetX; p.y = world.pointer.y - p.dragOffsetY; p.vx = p.vy = 0; } else { if (world.target) { const tdx=world.target.x-p.x; const tdy=world.target.y-p.y; const tdist=Math.hypot(tdx,tdy); if (tdist > p.speed * dt) { p.vx += ((tdx/tdist)*p.speed-p.vx)*0.2; p.vy += ((tdy/tdist)*p.speed-p.vy)*0.2; } else { p.x=world.target.x; p.y=world.target.y; p.vx=0;p.vy=0;world.target=null; } } else { p.vx += ((world.keys.right-world.keys.left)*p.speed-p.vx)*0.2; p.vy += ((world.keys.down-world.keys.up)*p.speed-p.vy)*0.2; } p.x += p.vx * dt; p.y += p.vy * dt; } p.x = clamp(p.x, 10, world.w - 140); p.y = clamp(p.y, 20, world.floorY - 140); 
    // FIX: Reduce Visual Effects on Mobile
    if (!p.isDragged && (Math.abs(p.vx)>0.5||Math.abs(p.vy)>0.5)) { 
        const trailColor=world.powerupActive?'#ffee88':'var(--fuzBody)'; 
        const trailChance = isMobile ? 0.15 : (world.powerupActive ? 0.7 : 0.3);
        if(Math.random() < trailChance) trail(p.x,p.y,trailColor); 
        if(Math.random()<0.15) {
            safeAudio(() => BooAudio.footstep());
        }
    }
    if (!p.isDragged && (Math.abs(p.vx)>0.1||Math.abs(p.vy)>0.1)) { world.targetAngle=Math.atan2(p.vy,p.vx); } const angleDiff=world.targetAngle-world.currentAngle; world.currentAngle += Math.atan2(Math.sin(angleDiff),Math.cos(angleDiff))*0.15;
    const faceRight = Math.cos(world.currentAngle)>-0.1; const lookingAtGhost = faceRight ? (g.x>=p.x) : (g.x<=p.x); g.shy = lookingAtGhost && Math.abs(g.y-p.y)<120 && Math.hypot(p.x-g.x, p.y-g.y)<400; let ghostMovement = 1; if(g.shy && !g.frozen){ g.freezeTimer+=dt; const progress=g.freezeTimer/FREEZE_THRESHOLD; if(Math.random()<0.08) safeAudio(() => BooAudio.freezeCharging(progress)); }else if(!g.frozen){ g.freezeTimer=Math.max(0,g.freezeTimer-dt*2); } if(g.freezeTimer>FREEZE_THRESHOLD){ if(!g.frozen){ safeAudio(() => BooAudio.freezeSuccess()); for (let i=0;i<3;i++) { setTimeout(() => safeAudio(() => BooAudio.pwmLead(880+i*50,0.2,5,10,0.1)),i*60); }} g.frozen=true; g.freezeTimer=FREEZE_DURATION; } if(g.frozen){ ghostMovement=0; g.freezeTimer-=dt; if(g.freezeTimer<0){ safeAudio(() => BooAudio.ghostUnfreeze()); g.frozen=false;} } const dx=p.x-g.x,dy=p.y-g.y; const dist=Math.hypot(dx,dy)||1; let want=(g.shy&&!g.frozen)?0:g.speed*ghostMovement; if(world.powerupActive&&world.powerupType==='repel'){want*=REPEL_FORCE;} if(want>0&&Math.random()<0.05) safeAudio(() => BooAudio.ghostChase()); g.vx+=((dx/dist)*want-g.vx)*0.08; g.vy+=((dy/dist)*want-g.vy)*0.08; g.x+=g.vx*dt; g.y+=g.vy*dt;

    // --- MODIFIED step() ---
    // NEW: Danger pulse update
    if (!g.frozen) {
      const DANGER_RADIUS = 450;
      const dangerDist = Math.hypot(p.x - g.x, p.y - g.y);
      const normalizedDanger = Math.min(1, dangerDist / DANGER_RADIUS);
      safeAudio(() => BooAudio.updateDangerPulse(normalizedDanger));
    } else {
      // Fade out pulse if ghost is frozen
      safeAudio(() => BooAudio.updateDangerPulse(1));
    }

    // FIX: Reduce Visual Effects on Mobile
    if((Math.abs(g.vx)>0.5||Math.abs(g.vy)>0.5) && Math.random() < (isMobile ? 0.08 : 0.15)) {
        ghostTrail(g.x,g.y,false);
    }
    world.miniGhosts.forEach((mini)=>{mini.offsetAngle+=0.02*dt;const orbitRadius=80+Math.sin(mini.offsetAngle*0.5)*20;const targetX=g.x+Math.cos(mini.offsetAngle)*orbitRadius;const targetY=g.y+Math.sin(mini.offsetAngle)*orbitRadius;const mdx=targetX-mini.x,mdy=targetY-mini.y;const mdist=Math.hypot(mdx,mdy)||1;mini.shy=g.shy;let mwant=(mini.shy&&!g.frozen)?0:mini.speed*ghostMovement;if(world.powerupActive&&world.powerupType==='repel'){mwant*=REPEL_FORCE;}mini.vx+=((mdx/mdist)*mwant-mini.vx)*0.1;mini.vy+=((mdy/mdist)*mwant-mini.vy)*0.1;mini.x+=mini.vx*dt;mini.y+=mini.vy*dt;
    if((Math.abs(mini.vx)>0.5||Math.abs(mini.vy)>0.5) && Math.random() < (isMobile ? 0.06 : 0.12)){ghostTrail(mini.x,mini.y,true);} // Also reduce mini ghost trails
    });
if (!p.isDragged) {
  // CANDY COLLECTION AND MAGNET
  for (const c of world.candies) {
    if (!c.isCollected && !c._lockCollect) {
      // magnet pull
      if (world.powerupActive && world.powerupType === "magnet") {
        const cdx = p.x - c.x;
        const cdy = p.y - c.y;
        const cdist = Math.hypot(cdx, cdy);
        if (cdist < MAGNET_RADIUS && cdist > 1) {
          c.x += (cdx / cdist) * 2 * dt;
          c.y += (cdy / cdist) * 2 * dt;
        }
      }

      // player touches candy - ONLY ONE PER FRAME
      if (!candyCollectionThisFrame && checkCollision(p, c, 50)) {
        // IMMEDIATELY lock both the candy AND the frame
        c._lockCollect = true;
        c.isCollected = true;
        candyCollectionThisFrame = true; // Prevent any more this frame

        // Score FIRST (synchronous, can't fail)
        updateScore(CANDY_SCORE, c.x + 20, c.y + 20);

        // Visual feedback (synchronous, minimal)
        if (c.el && c.el.parentNode) {
          c.el.style.opacity = "0";
          c.el.style.pointerEvents = "none";
          c.el.classList.add("collected");
        }

        // Burst (throttled, in try-catch)
        try {
          burst(c.x + 20, c.y + 20, "var(--spookEdge)");
        } catch (e) {}

        // Audio - fire and forget, no blocking
        setTimeout(() => {
          safeAudio(() => BooAudio.candyCollect());
        }, 0);

        // Check portal spawn
        setTimeout(() => {
          const allCollected = world.candies.every(cc => cc.isCollected);
          if (allCollected && !world.portalActive) {
            world.portalActive = true;
            try {
              if (BooAudio?.ctx?.state === "running") {
                BooAudio.filter.frequency.linearRampToValueAtTime(400, BooAudio.ctx.currentTime + 1.5);
              }
            } catch (e) {}
            createPortal();
          }
        }, 100); // Delayed check to ensure all locks are set

        // Unlock after animation
        setTimeout(() => {
          c._lockCollect = false;
        }, 600);

        break; // Exit loop immediately after collecting one candy
      }
    }
  }

  // POWERUP COLLISION
  if (world.powerup && checkCollision(p, world.powerup, 50)) {
    safeAudio(() => {
        BooAudio.powerupCollect();
        if (BooAudio?.ctx) {
            BooAudio.filter.frequency.linearRampToValueAtTime(4000, BooAudio.ctx.currentTime + 0.5);
        }
    });
    world.powerupActive = true;
    world.powerupTimer = POWERUP_DURATION;
    if (world.powerupType === "speed") {
      p.speed = p.baseSpeed * 2;
      playerEl.classList.add("boosted");
    }
    world.powerup.el.remove();
    world.powerup = null;
    world.powerupSpawnTimer = 900 + Math.random() * 600;
  }

  // WEB COLLISION
  for (const w of world.webs) {
    if (checkCollision(p, w, 50)) {
      safeAudio(() => BooAudio.webHit());
      world.debuffActive = true;
      world.debuffTimer = DEBUFF_DURATION;
      p.speed = p.baseSpeed * 0.5;
      for (const c of world.candies) {
        if (c.isCollected) {
          updateScore(-CANDY_SCORE);
          try {
            burst(c.x + 20, c.y + 20, "var(--mouth)");
          } catch (e) {}
        }
        c.isCollected = false;
        c._lockCollect = false;
        c.el.classList.remove("collected");
        c.el.style.opacity = 1;
        c.el.style.transform = "";
        c.el.style.pointerEvents = "";
        respawnCandy(c);
      }
      world.portalActive = false;
      if (world.portal) {
        world.portal.el.remove();
        world.portal = null;
      }
      w.el.remove();
      world.webs = world.webs.filter((web) => web !== w);
      break; // Only hit one web per frame
    }
  }
}
    for (const w of world.webs) { const webBob = Math.sin(world.time*0.1+w.bobOffset)*8; w.el.style.transform=`translate(${w.x}px,${w.y+webBob}px)`; }
    const allGhosts = [g, ...world.miniGhosts]; for(const ghost of allGhosts) { if(!ghost.frozen){for(const c of world.candies){if(!c.isCollected && checkCollision(ghost,c,40)){safeAudio(() => BooAudio.candyEaten());updateScore(-CANDY_SCORE);burst(c.x+20,c.y+20,"var(--mouth)");respawnCandy(c);break;}}} const isMainGhost=ghost===g; const radius=isMainGhost?70:50; if (!p.isDragged&&checkCollision(p,ghost,radius)) { if (isMainGhost&&ghost.frozen) { safeAudio(() => BooAudio.shatterFrozenGhost()); burst(ghost.x+60,ghost.y+60); ghost.frozen=false; ghost.freezeTimer=0; ghost.x=Math.random()*world.w; ghost.y=50+Math.random()*(world.floorY-200); updateScore(CANDY_SCORE*2, ghost.x, ghost.y); safeAudio(() => BooAudio.screenShake()); document.body.style.transform="translate(3px,3px)"; setTimeout(()=>document.body.style.transform="",100); } else if (!ghost.frozen) { safeAudio(() => BooAudio.ghostBoo()); safeAudio(() => BooAudio.screenShake()); updateScore(-CANDY_SCORE); world.wasHit=true; p.vx=-(ghost.x-p.x)*0.1;p.vy=-(ghost.y-p.y)*0.1; const booEl=document.getElementById("boo-scare"); booEl.style.transform="translate(-50%,-50%) scale(1.5) rotate("+(Math.random()*20-10)+"deg)"; booEl.style.opacity="1"; document.body.style.filter="brightness(1.5) contrast(1.3)"; document.body.style.transform="translate("+(Math.random()*10-5)+"px,"+(Math.random()*10-5)+"px) scale(1.05)"; setTimeout(()=>{ booEl.style.transform="translate(-50%,-50%) scale(0)"; booEl.style.opacity="0"; document.body.style.filter=""; document.body.style.transform=""; },250); } } }
    if (!p.isDragged && world.portal && checkCollision(p, world.portal, 80)) { startNextLevel(); }

    if (p.isDragged) { paintPixels(playerEl, makeFuzMaskDragged(world.time), paletteFuz); const liftHeight = Math.max(0, world.floorY-p.y-120); const shadowScale = 1+(liftHeight/world.h)*1.5; const shadowOpacity = Math.max(0, 0.4-(liftHeight/world.h)*0.8); playerShadowEl.style.opacity = shadowOpacity; playerShadowEl.style.transform = `translateX(${p.x+25}px) scale(${shadowScale})`; playerShadowEl.style.visibility = 'visible'; } else { const playerBob = Math.sin(world.time * (world.powerupActive?0.8:0.3)) * 1.5; paintPixels(playerEl, makeFuzMask(world.currentAngle, playerBob), paletteFuz); playerShadowEl.style.opacity=0; playerShadowEl.style.visibility='hidden'; }
    const scale = p.isDragged ? 1.1 : 1; if(!p.isDragged) playerEl.style.transform = `translate(${p.x}px,${p.y}px) scale(${scale})`; else playerEl.style.transform = `translate(${p.x}px,${p.y}px) scale(${scale})`;

    for (const c of world.candies) { if (!c.isCollected) { const candyBob = Math.sin(world.time*0.1+c.bobOffset)*10; c.el.style.transform=`translate(${c.x}px,${c.y+candyBob}px)`; } }
    if (world.powerup) { const powerupBob = Math.sin(world.time*0.2+world.powerup.bobOffset)*12; world.powerup.el.style.transform=`translate(${world.powerup.x}px,${world.powerup.y+powerupBob}px)`; }
    if (world.portal) { const portalBob = Math.sin(world.time*0.15+world.portal.bobOffset)*8; world.portal.el.style.transform=`translate(${world.portal.x}px, ${world.portal.y+portalBob}px)`; if (Math.random()<0.008) safeAudio(() => BooAudio.portalAmbient()); }
    const freezeProgress=clamp(g.freezeTimer/FREEZE_THRESHOLD,0,1); freezeMeterFill.style.width=`${freezeProgress*100}%`; freezeMeterContainer.style.opacity=(g.shy&&!g.frozen&&g.freezeTimer>0)?1:0; const baseShyFilter="drop-shadow(0 0 4px rgba(120,180,255,0.8))"; const baseChaseFilter="drop-shadow(0 0 10px rgba(255,160,200,0.5))"; const frozenFilter="hue-rotate(180deg) brightness(1.2)"; let currentFilter = g.shy?baseShyFilter:baseChaseFilter; if (g.frozen) { currentFilter=frozenFilter; } else if (g.shy&&g.freezeTimer>0) { const chargeRatio=g.freezeTimer/FREEZE_THRESHOLD; currentFilter=`hue-rotate(${chargeRatio*180}deg) brightness(${1+chargeRatio*0.2}) ${baseShyFilter}`; } spookEl.style.filter=currentFilter; spookEl.style.transform=`translate(${g.x}px,${g.y}px)`; spookEl.style.opacity=g.shy?0.65:1; const phaseAmount=g.shy?Math.sin(world.time*0.2)*30+30:0; if(phaseAmount>0){spookEl.style.clipPath=`polygon(0% ${phaseAmount}%, 100% ${phaseAmount}%, 100% 100%, 0% 100%)`;}else{spookEl.style.clipPath="none";}
    world.miniGhosts.forEach(mini => { mini.el.style.filter=currentFilter; mini.el.style.transform=`translate(${mini.x}px,${mini.y}px) scale(0.9)`; mini.el.style.opacity=mini.shy?0.6:0.95; });
  }

  // FIX: Frame Rate Throttling
  let last = performance.now();
  function loop(t) { 
    const elapsed = t - last;
    
    // Mobile: only update at target framerate
    if (isMobile && elapsed < FRAME_TIME) {
      requestAnimationFrame(loop);
      return;
    }
    
    last = t;
    const dt = Math.min(2.0, elapsed / 16.67); 
    step(dt); 
    requestAnimationFrame(loop); 
  }

  const muteBtn = document.getElementById('mute-btn'); const pauseBtn = document.getElementById("pause-btn");
  muteBtn.addEventListener('click', () => { BooAudio.toggleMute(); muteBtn.textContent = BooAudio.isMuted ? 'Unmute 🔇' : 'Mute 🔊'; });
  pauseBtn.addEventListener("click", togglePause);
  if (isMobile) { 
    pauseBtn.style.display = "block"; 
  }

  // --- AUTOPLAY INITIAL UI SETUP ---
  const instructionsEl = document.getElementById('instructions');
  instructionsEl.innerHTML = '👻 Autoplay in Progress! 🎃 <b>Interact to Take Control!</b>';
  instructionsEl.style.textAlign = 'center';
  instructionsEl.style.left = '50%';
  instructionsEl.style.transform = 'translateX(-50%)';
  instructionsEl.style.width = '300px';
  // --- END AUTOPLAY INITIAL UI SETUP ---

  requestAnimationFrame(loop);
</script>

<!-- WIN SCREEN HTML -->
<div id="win-screen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 10, 15, 0.85); display: none; align-items: center; justify-content: center; flex-direction: column; z-index: 500; text-align: center; color: white; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); font-size: 24px; padding: 20px; box-sizing: border-box;">
  <h1 style="font-size: 60px; color: #ffd700; text-shadow: 0 0 20px #ffc40c;">🎃 YOU WON! 🎃</h1>
  <p>You've collected enough candy for one year! Well done!</p>
  <p style="margin-top: 30px; font-size: 32px;">Final Score: <b id="win-score" style="color: #ffd700;">0</b></p>
  <button id="play-again-btn" style="margin-top: 40px; padding: 15px 30px; font-size: 22px; cursor: pointer; background: var(--candyWrapper); color: white; border: 2px solid #ffdd44; border-radius: 8px; font-family: 'Pixelify Sans', sans-serif; text-shadow: 0 0 5px rgba(0,0,0,0.4);">Play Again?</button>
</div>

</body>
</html>
    
  </body>
  
</html>
